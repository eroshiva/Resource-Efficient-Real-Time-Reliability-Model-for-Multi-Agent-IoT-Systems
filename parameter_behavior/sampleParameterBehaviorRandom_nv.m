%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Simple script to simulate single parameter behavior when one value
%%% fluctuates
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% Clean workspace
close all;
clear all;
clc;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% Part I - SLA satisfactory impact on the parameter
%%% SLA is given and couldn't be changed - no freedom, either YES or NO.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Input data 
% Defining number of iterations
steps = 200;
x_axis = 1:steps; % dummy vector for graph representation

% Defining deviation in percentage from reference value
resPerc = 0.1;
latPerc = 0.05;

% Defining resource deviations (OS background processes)
sigma_CPU = resPerc*0.54;
sigma_RAM = resPerc*0.3;
sigma_NI = resPerc*0.73;
sigma_Storage = resPerc*0.54;

% Defining average request processing time deviations (OS background processes)
delta_CPU = latPerc*0.3;
delta_RAM = latPerc*0.009;
delta_NI = latPerc*0.07;
delta_Storage = latPerc*0.44;

%% Measurement Ist parameter - free resources
% Output variable
slaRes = [1, 1, 1, 1]; % workload values per SLA (same units as workload values)
% 1 corresponds to the maximum possible workload on the component,
% when all resources are loaded - this trick is used to re-use same function
% measureP on that parameter

% Priority distributions per customer's requirements - sum of a vector
% should be equal to 1
lPr = [0.6, 0.01, 0.25, 0.09]; % workload priorities --> sets sensitivity of the parameter to deviations of each element

% Defining resource usage vector
wrkld = zeros(4, steps);
wrkld(1,:) = normrnd(0.46,sigma_CPU,1,steps); % CPU
wrkld(2,:) = normrnd(0.7,sigma_RAM,1,steps); % RAM
wrkld(3,:) = normrnd(0.27,sigma_NI,1,steps); % NI
wrkld(4,:) = normrnd(0.46,sigma_Storage,1,steps); % Storage

% Defining fluctuations - 1st Agent running
wrkld(1,25:50) = normrnd(0.76,sigma_CPU,1,26); % CPU
wrkld(2,25:steps) = normrnd(0.79,sigma_RAM,1,steps-24); % RAM - app didn't outloaded from RAM after it ended it's execution
wrkld(3,25:50) = normrnd(0.9,sigma_NI,1,26); % NI
wrkld(4,25:steps) = normrnd(0.55,sigma_Storage,1,steps-24); % Storage - data generated by app has been stored

% Defining fluctuations - 2nd Agent running
wrkld(1,70:100) = normrnd(1,sigma_CPU,1,31); % CPU
wrkld(2,70:steps) = normrnd(0.81,sigma_RAM,1,steps-69); % RAM - app didn't outloaded from RAM after it ended it's execution
wrkld(3,70:100) = normrnd(0.5,sigma_NI,1,31); % NI
wrkld(4,70:steps) = normrnd(0.6,sigma_Storage,1,steps-69); % Storage - data generated by app has been stored

% Defining fluctuations - 3rd Agent running
wrkld(1,130:145) = normrnd(1,sigma_CPU,1,16); % CPU
wrkld(2,130:steps) = normrnd(0.89,sigma_RAM,1,steps-129); % RAM - app didn't outloaded from RAM after it ended it's execution
wrkld(3,130:145) = normrnd(0.91,sigma_NI,1,16); % NI
wrkld(4,130:steps) = normrnd(0.85,sigma_Storage,1,steps-129); % Storage - data generated by app has been stored

% Defining fluctuations - 4th Agent running
wrkld(1,160:185) = normrnd(0.89,sigma_CPU,1,26); % CPU
wrkld(2,160:steps) = normrnd(0.9,sigma_RAM,1,steps-159); % RAM - app didn't outloaded from RAM after it ended it's execution
wrkld(3,160:185) = normrnd(0.81,sigma_NI,1,26); % NI
wrkld(4,160:steps) = 1; % Storage - data generated by app has been stored

% To make sure we do not exceed borders from 0 to 1
for i = 1:4
    for j = 1:steps
        if wrkld(i,j) > 1
            wrkld(i,j) = 1;
        end
        if wrkld(i,j) < 0
            wrkld(i,j) = 0;
        end
   end
end

[parameterRes, metricsWrkld] = measurePnv(steps,wrkld,slaRes,lPr);

%% Plotting dependency graph
figure(1);
plot(x_axis, parameterRes, '-X');
grid on;
title('Workload parameter behavior'); % Lower parameter is, more resources are consumed on the device (i.e. running app)
% legend('CPU', 'RAM', 'NI', 'Storage', 'all');
ylabel('Parameter [-]');
xlabel('Time [s]');

%% Measurement IInd parameter - Average Request Processing Time
% parameterLat = zeros(1,steps);
slaL = [0.5, 0.015, 0.15, 0.6]; % SLA values
lPr = [0.55, 0.01, 0.34, 0.1]; % Setting processing time priorities
% Defining processing time vector
arpt = zeros(4, steps);
arpt(1,:) = normrnd(0.3,delta_CPU,1,steps); % Only first part will be changing (CPU)
arpt(2,:) = normrnd(0.009,delta_RAM,1,steps);
arpt(3,:) = normrnd(0.07,delta_NI,1,steps);
arpt(4,:) = normrnd(0.44,delta_Storage,1,steps);

% Defining fluctuations - 1st app running
arpt(1,25:50) = normrnd(0.39,delta_CPU,1,26); % CPU
arpt(2,25:steps) = normrnd(0.011,delta_RAM,1,steps-24); % RAM - app didn't outloaded from RAM after it ended it's execution
arpt(3,25:50) = normrnd(0.13,delta_NI,1,26); % NI
arpt(4,25:steps) = normrnd(0.48,delta_Storage,1,steps-24); % Storage - data generated by app has been stored

% Defining fluctuations - 2nd app running
arpt(1,70:100) = normrnd(1,delta_CPU,1,31); % CPU %%%%%%%%%% WARNING %%%%%%%%%%%%
arpt(2,70:steps) = normrnd(0.013,delta_RAM,1,steps-69); % RAM - app didn't outloaded from RAM after it ended it's execution
arpt(3,70:100) = normrnd(0.09,delta_NI,1,31); % NI
arpt(4,70:steps) = normrnd(0.52,delta_Storage,1,steps-69); % Storage - data generated by app has been stored

% Defining fluctuations - 3rd app running
arpt(1,130:145) = normrnd(1,delta_CPU,1,16); % CPU
arpt(2,130:steps) = normrnd(0.014,delta_RAM,1,steps-129); % RAM - app didn't outloaded from RAM after it ended it's execution
arpt(3,130:145) = normrnd(0.2,delta_NI,1,16); % NI
arpt(4,130:steps) = normrnd(0.57,delta_Storage,1,steps-129); % Storage - data generated by app has been stored

% Defining fluctuations - 4th app running
arpt(1,160:185) = normrnd(0.47,delta_CPU,1,26); % CPU
arpt(2,160:steps) = normrnd(0.02,delta_RAM,1,steps-159); % RAM - app didn't outloaded from RAM after it ended it's execution
arpt(3,160:185) = normrnd(0.14,delta_NI,1,26); % NI
arpt(4,160:steps) = normrnd(0.9,delta_Storage,1,steps-159); % Storage - data generated by app has been stored

% To make sure we do not have negative value (processing time can't be negative)
for i = 1:4
    for j = 1:steps
        if arpt(i,j) < 0
            arpt(i,j) = 0;
        end
   end
end

[parameterArpt, metricsARPT] = measurePnv(steps,arpt,slaL,lPr);

%% Plotting dependency graph
figure(2);
plot(x_axis, parameterArpt(1,:), '-X');
grid on;
title('ARPT parameter behavior'); % (more on the left - SLA isn't fullfilled, more on the right - SLA is fulfilled)
% legend('CPU', 'RAM', 'NI', 'Storage', 'all');
ylabel('Parameter [-]');
xlabel('Time [s]');

%% Measurement IIIrd parameter - all time availability

slaAv = [0.95, 0.8, 0.5, 0.84];
avPr = [0.45, 0.09, 0.1, 0.36];

% Defining last 5 minutes availability vector
lastTAv = zeros(4, steps);
lastTAv(1,:) = 0.99;
lastTAv(2,:) = 0.99;
lastTAv(3,:) = 0.99;
lastTAv(4,:) = 0.99;

% Last 5 minutes availability
% Generating with regard to resource outage and processing time unsatisfaction
for j = 1:steps
    if wrkld(1,j) <= 0 || arpt(1,j)/slaL(1) >= 1
        lastTAv(1,j:steps) = lastTAv(1,j) - 0.02;
    else
        if lastTAv(1,j) < 0.98
            lastTAv(1,j:steps) = lastTAv(1,j) + 0.02;
        else
            lastTAv(1,j:steps) = 0.99;
        end
    end
    if wrkld(2,j) <= 0 || arpt(2,j)/slaL(2) >= 1
        lastTAv(2,j:steps) = lastTAv(2,j) - 0.02;
    else
        if lastTAv(2,j) < 0.98
            lastTAv(2,j:steps) = lastTAv(2,j) + 0.02;
        else
            lastTAv(2,j:steps) = 0.99;
        end
    end
    if wrkld(3,j) <= 0 || arpt(3,j)/slaL(3) >= 1
        lastTAv(3,j:steps) = lastTAv(3,j) - 0.02;
    else
        if lastTAv(3,j) < 0.98
            lastTAv(3,j:steps) = lastTAv(3,j) + 0.02;
        else
            lastTAv(3,j:steps) = 0.99;
        end
    end
    if wrkld(4,j) <= 0 || arpt(4,j)/slaL(4) >= 1
        lastTAv(4,j:steps) = lastTAv(4,j) - 0.02;
    else
        if lastTAv(4,j) < 0.98
            lastTAv(4,j:steps) = lastTAv(4,j) + 0.02;
        else
            lastTAv(4,j:steps) = 0.99;
        end
    end
end

% Computing availability input metrics
metricsAv = zeros(4, steps);
parameterAvL = zeros(1, steps);
for j = 1:steps
    metricsAv(:,j) = slaAv./lastTAv(:,j)'; % transponing is needed to set correct dimension (result should be a vector, not a matrix)
    metricsAv(:,j) = 1 - metricsAv(:,j);
    parameterAvL(1,j) = metricsAv(:,j)'*avPr';
end


%% Plotting dependency graph
figure(3);
plot(x_axis, parameterAvL, '-X');
grid on;
title('Last 5 minutes availability parameter behavior');
ylabel('Parameter [-]');
xlabel('Time [s]');

%% Computing reliability
reliability = zeros(1,steps);
prRel = [0.4; 0.55; 0.05]; % Reliability priorities
for j = 1:steps
    reliability(j) = [parameterRes(j), parameterArpt(j), parameterAvL(j)]*prRel;
end

%% Plotting reliability graph
figure(4);
plot(x_axis, reliability, '-X');
grid on;
yline(mean(reliability(1:25)));
yline(0);
hold off;
title('Reliability of the system');
ylabel('Reliability [-]');
xlabel('Time [s]');
ylim([-1,1]);

print -deps rlblt

%% Plotting input data values for Workload
figure(5);
subplot(2,2,1);
plot(x_axis, wrkld(1,:)); 
grid on;
title('Workload input data values for CPU'); 
ylabel('Workload for CPU [-]');
xlabel('Time [s]');
yline(mean(wrkld(1,1:25)));
ylim([0,1]);

subplot(2,2,2);
plot(x_axis, wrkld(2,:)); 
grid on;
title('Workload input data values for RAM');
ylabel('Workload for RAM [-]');
xlabel('Time [s]');
yline(mean(wrkld(2,1:25)));
ylim([0,1]);

subplot(2,2,3);
plot(x_axis, wrkld(3,:)); 
grid on;
title('Workload input data values for NI'); 
ylabel('Workload for NI [-]');
xlabel('Time [s]');
yline(mean(wrkld(3,1:25)));
ylim([0,1]);

subplot(2,2,4);
plot(x_axis, wrkld(4,:));
grid on;
title('Workload input data values for Storage'); 
ylabel('Workload for Storage [-]');
xlabel('Time [s]');
yline(mean(wrkld(4,1:25)));
ylim([0,1]);

%% Plotting input metrics for Workload
figure(6);
subplot(2,2,1);
plot(x_axis, metricsWrkld(1,:)); 
grid on;
title('Workload metrics for CPU'); 
ylabel('Workload for CPU [-]');
xlabel('Time [s]');
yline(mean(metricsWrkld(1,1:25)));
ylim([0,1]);

subplot(2,2,2);
plot(x_axis, metricsWrkld(2,:)); 
grid on;
title('Workload metrics for RAM'); 
ylabel('Workload for RAM [-]');
xlabel('Time [s]');
yline(mean(metricsWrkld(2,1:25)));
ylim([0,1]);

subplot(2,2,3);
plot(x_axis, metricsWrkld(3,:)); 
grid on;
title('Workload metrics for NI'); 
ylabel('Workload for NI [-]');
xlabel('Time [s]');
yline(mean(metricsWrkld(3,1:25)));
ylim([0,1]);

subplot(2,2,4);
plot(x_axis, metricsWrkld(4,:)); 
grid on;
title('Workload metrics for Storage'); 
ylabel('Workload for Storage [-]');
xlabel('Time [s]');
yline(mean(metricsWrkld(4,1:25)));
ylim([0,1]);

print -deps wrkldAll

%% Plotting input data values for ARPT
figure(7);
subplot(2,2,1);
plot(x_axis, arpt(1,:));
grid on;
title('ARPT input data values for CPU'); 
ylabel('Processing Time for CPU [s]');
xlabel('Time [s]');
yline(mean(metricsARPT(1,1:25)));
yline(0);
ylim([0,1.1]);

subplot(2,2,2);
plot(x_axis, arpt(2,:));
grid on;
title('ARPT input data values for RAM'); 
ylabel('ARPT for RAM [s]');
xlabel('Time [s]');
yline(mean(arpt(2,1:25)));
yline(0);
ylim([0,1.1]);
% ylim([0,0.1]);

subplot(2,2,3);
plot(x_axis, arpt(3,:));
grid on;
title('ARPT input data values for NI'); 
ylabel('ARPT for NI [s]');
xlabel('Time [s]');
yline(mean(arpt(3,1:25)));
yline(0);
ylim([0,1.1]);
% ylim([0,0.3]);

subplot(2,2,4);
plot(x_axis, arpt(4,:));
grid on;
title('ARPT input data values for Storage'); 
ylabel('ARPT for Storage [s]');
xlabel('Time [s]');
yline(mean(arpt(4,1:25)));
yline(0);
ylim([0,1.1]);
% ylim([0,1]);

%% Plotting input metrics for ARPT
figure(8);
subplot(2,2,1);
plot(x_axis, metricsARPT(1,:));
grid on;
title('ARPT metrics for CPU'); 
ylabel('Processing Time for CPU [s]');
xlabel('Time [s]');
yline(mean(metricsARPT(1,1:25)));
yline(0);
ylim([-1.1,1]);

subplot(2,2,2);
plot(x_axis, metricsARPT(2,:));
grid on;
title('ARPT metrics for RAM'); 
ylabel('ARPT for RAM [s]');
xlabel('Time [s]');
yline(mean(metricsARPT(2,1:25)));
yline(0);
ylim([-1.1,1]);

subplot(2,2,3);
plot(x_axis, metricsARPT(3,:));
grid on;
title('ARPT metrics for NI'); 
ylabel('ARPT for NI [s]');
xlabel('Time [s]');
yline(mean(metricsARPT(3,1:25)));
yline(0);
ylim([-1.1,1]);

subplot(2,2,4);
plot(x_axis, metricsARPT(4,:));
grid on;
title('ARPT metrics for Storage'); 
ylabel('ARPT for Storage [s]');
xlabel('Time [s]');
yline(mean(metricsARPT(4,1:25)));
yline(0);
ylim([-1.1,1]);

print -deps prcsTmAll

%% Plotting inputdata values for availability
figure(9);
subplot(2,2,1);
plot(x_axis, lastTAv(1,:));
grid on;
title('Availability input data values for CPU');
ylabel('Availability of the CPU [-]');
xlabel('Time [s]');
yline(mean(lastTAv(1,1:25)));
ylim([0,1]);

subplot(2,2,2);
plot(x_axis, lastTAv(2,:));
grid on;
title('Availability input data values for RAM');
ylabel('Availability of the RAM [-]');
xlabel('Time [s]');
yline(mean(lastTAv(2,1:25)));
ylim([0,1]);

subplot(2,2,3);
plot(x_axis, lastTAv(3,:));
grid on;
title('Availability input data values for NI');
ylabel('Availability of the NI [-]');
xlabel('Time [s]');
yline(mean(lastTAv(3,1:25)));
ylim([0,1]);

subplot(2,2,4);
plot(x_axis, lastTAv(4,:));
grid on;
title('Availability input data values for Storage');
ylabel('Availability of the Storage [-]');
xlabel('Time [s]');
yline(mean(lastTAv(4,1:25)));
ylim([0,1]);

%% Plotting input metrics for Availability
figure(10);
subplot(2,2,1);
plot(x_axis, metricsAv(1,:));
grid on;
title('Availability metrics for CPU');
ylabel('Availability of the CPU [-]');
xlabel('Time [s]');
yline(mean(metricsAv(1,1:25)));
ylim([-4,1]);
% ylim([-1.7,1]);

subplot(2,2,2);
plot(x_axis, metricsAv(2,:));
grid on;
title('Availability metrics for RAM');
ylabel('Availability of the RAM [-]');
xlabel('Time [s]');
yline(mean(metricsAv(2,1:25)));
ylim([-4,1]);

subplot(2,2,3);
plot(x_axis, metricsAv(3,:));
grid on;
title('Availability metrics for NI');
ylabel('Availability of the NI [-]');
xlabel('Time [s]');
yline(mean(metricsAv(3,1:25)));
ylim([-4,1]);
% ylim([0,1]);

subplot(2,2,4);
plot(x_axis, metricsAv(4,:));
grid on;
title('Availability metrics for Storage');
ylabel('Availability of the Storage [-]');
xlabel('Time [s]');
yline(mean(metricsAv(4,1:25)));
ylim([-4,1]);

print -deps l5mAvAll

%%
figure(11);
subplot(1,3,1);
plot(x_axis, parameterRes);
grid on;
title('Workload parameter');
ylabel('Workload [-]');
xlabel('Time [s]');
yline(mean(parameterRes(1:25)));
ylim([-2,1]);

subplot(1,3,2);
plot(x_axis, parameterArpt);
grid on;
title('ARPT parameter');
ylabel('ARPT parameter [-]');
xlabel('Time [s]');
yline(mean(parameterArpt(1:25)));
ylim([-2,1]);

subplot(1,3,3);
plot(x_axis, parameterAvL);
grid on;
title('Availability parameter');
ylabel('Availability parameter [-]');
xlabel('Time [s]');
yline(mean(parameterAvL(1:25)));
ylim([-2,1]);

print -deps paramsAll

%% Saving workspace
% filename = sprintf('lab_computation_ertCore_%s.mat', datestr(now,'dd-mm-yyyy_HH-MM'));
% save(filename);
% save("simulationPaper.mat")
